> mkdir ecom
> cd ecom
ecom> dotnet -h
ecom> dotnet new sln
ecom> dotnet new webapi -o API
ecom> dotnet sln -h
ecom> dotnet sln add API

ecom> dotnet new classlib -o Core
ecom> dotnet new classlib -o Infrastructure
ecom> dotnet sln add Core
ecom> dotnet sln add Infrastructure


Here Core will contain all our entities
Infrastructure will contain all our migrations

In API add refrence of Infrastructure
In Infrastructure add reference of Core


Add a .gitignore file in the ecom dir

and initialize git repo in the ecom

Here we will be using repository pattern:----------------------------------------

Client request
Controllers (IRepository)	---> GetProducts(), GetProduct(int id)
Repository 			---> _context.Products.ToList()
DbContext			---> select * from products
database 


Add EntityFramework in the Infrastructure class lib by:
Infrastructure -> Dependencies -> rightclick -> Manage Newget packages -> browse -> EntityFramework -> add

All the verions of packages must be same to the 
dotnet version
e.g 5.0.4 should be followed when installing packages


PM> dotnet
PM> dotnet --version
5.0.404

PM> dotnet tool install --global dotnet-ef 		// we cant just download any version , vsersion must be >=dotnet package
PM> dotnet tool install --global dotnet-ef --version 5.0.4
PM> dotnet tool list -g
PM> dotnet ef -h
PM> dotnet ef migrations add InitialCreate -o Data/Migrations // will not work as we need to goto a perticular dir
PM> dir
PM> cd API
PM> dotnet ef migrations add InitialCreate -o Data/Migrations // migrations created in a specific dir
PM> dotnet ef database -h 
PM> dotnet ef database update



Use 
using Microsoft.EntityFrameworkCore;
instead of
using System.Data.Entity;


In order to create new Migration from begining:
1) Goto sqlserver and delete all tables inside the DB
2) and Remove all the migrations from the Migrations folder
3) again add migrations

In order to generate migrations in a particular class lib dir

first goto the project level from a particlar class lib or project:
If we are inside API:

PM> cd ..
PM> dir

Now we are in base dir i.e Ecom

PM> dotnet ef migrations add InitialCreate -p Infrastructure -s API -o Data/Migrations

dotnet ef -> the package name
migrations -> we will be working with migrations
add InitialCreate -> adding a new migrations 
-p Infrastructure -> the project where we are applying migrations
-s API -> need to specify starting project 
-o Data/Migrations -> In which folder we need to save the Migrations


CHANGES TILL NOW DONOT MAKE SENSE:
1) In the Program.cs file we have changes the main method which helps in 
	Applying the migrations and creating the Database at app startup
2) In the Infrastructure we added 'SeedData' folder and 'StoreContextSeed.cs' file
	which is used to add data from the json file to the tables on app startup



IN ORDER TO GET DATA INTO OUR SQL TABLES FROM JSON FILES:--------------------------------------

USE [EcomDB]
GO

/*  

F:\dotnet+angular\ecom\EXTRAS\SeedData\brands.json
is just the path 
copy path and paste it here 

Below code is to add json data from a fiel.json to sql server table

*/

Declare @JSON varchar(max)
SELECT @JSON=BulkColumn
FROM OPENROWSET (BULK 'F:\dotnet+angular\ecom\EXTRAS\SeedData\brands.json', SINGLE_CLOB) import

INSERT INTO [dbo].[ProductBrands]
SELECT *
FROM OPENJSON (@JSON)
WITH 
(
	[Name] nvarchar(max)
)
GO


delete from [dbo].[ProductBrands]

select * from [dbo].[ProductBrands]

/*

Below code
Used to reset the index to 1 so that indexing can again start from 1

*/
DBCC CHECKIDENT ('[ProductBrands]', RESEED, 0);
GO



2 branch created:
1) boilerplare_code
2) main-advanced

In order to push code in main-advanced branch now onwards:

> git checkout -b main-advanced
> git add .
> git commit -m "Repository Pattern Added advanced"
> git push origin main-advanced
> git status
	On branch main-advanced
	nothing to commit, working tree clean


> git branch
  main
* main-advanced

> git checkout main
Switched to branch 'main'
Your branch is up to date with 'origin/main'.

> git branch
* main
  main-advanced

> git checkout main-advanced
Switched to branch 'main-advanced'

> git branch
  main
* main-advanced



We can switch between branches and we can see diff codes totally 
even locally
we can see in which branch we are in by using 'git branch'

We can clone code from a branch:
git clone -b <branchname> <remote-repo-url>

git pull   ->   to pull changes from main tracked branch


In order to use DTO:
we need 
AutoMapper.Extensions.Microsoft.DependencyInjection


NOTE:
Loading static files:
Those files which needs to be loaded as it is when we are hitting an url needs to be kept under
'wwwroot' folder inside main project (In our API)

And we need to add a middleware in the Configure Method in Startup.cs
NOTE: as sequencing of middlewares are important:----------------------------------------------

We need to add one middleware 'app.UseStaticFiles()' under the 'app.UseRouting()'

	app.UseRouting();

        app.UseStaticFiles(); // load static images -

And Job is done



ALLOW CORS:--------------------------------------------------------------------------------------------------

using API.Helpers;
using API.Middleware;
using Core.Interfaces;
using Infrastructure.Data;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Diagnostics;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.OpenApi.Models;
using Newtonsoft.Json;

namespace API
{
    public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddControllers();
            // to pass _repo in ProductsController
            services.AddScoped<IProductRepository,ProductRepository>(); 
            // used to add connection string in the DbContext class
            services.AddDbContext<StoreContext>(options =>
            {
                options.UseSqlServer(Configuration["ConnectionString:EcomDB"]);
            });
            // to map DTOs to Entities
            services.AddAutoMapper(typeof(MappingProfiles));

            services.AddSwaggerGen(c =>
            {
                c.SwaggerDoc("v1", new OpenApiInfo { Title = "API", Version = "v1" });
            });

            // adding the src from where we will only be accepting http requests-------------------------here-------------------------
            services.AddCors(opt =>
            {
                opt.AddPolicy("CorsPolicy", policy =>
                {
                    policy.AllowAnyHeader().AllowAnyMethod().AllowAnyOrigin(); // accepting http req from any origin
                    //policy.AllowAnyHeader().AllowAnyMethod().WithOrigins("https://localhost:4200");
                });
            });
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            //app.UseMiddleware<ExceptionMiddleware>(); // to format the error responses

            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
                app.UseSwagger();
                app.UseSwaggerUI(c => c.SwaggerEndpoint("/swagger/v1/swagger.json", "API v1"));
            }

            app.UseStatusCodePagesWithReExecute("/errors/{0}"); // to handle page not found - it will hit the ErrorController

            app.UseHttpsRedirection();

            app.UseRouting();

            app.UseStaticFiles(); // load static images -

            app.UseCors("CorsPolicy"); // adding cors ----------------------------------------------------here------------------------

            app.UseAuthorization();

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllers();
            });
        }
    }
}




CLIENT:-------------------------------------------------------------------------------------------------------------

We will be using angular boostrap: link: https://valor-software.com/ngx-bootstrap/#/

In order to test versions: https://unpkg.com/browse/@angular/core@12.2.13/package.json

In order to use nvm: we need to open cmd as administrator and use nvm commands:
> nvm ls
> nvm use [version-name]


In order to add bootswatch:-------------------------------------------------------------------------------------------------------------------------

> npm i bootswatch

Then in styles.css: -> add this below line:

import "bootswatch/dist/[theme]/bootstrap.min.css";

-----------------------------------------------------------------------------------------------------------------------------------------------------

add bootstrap and styles to our project:

> ng add ngx-bootstrap
> npm install font-awesome

Inside angular.json:
Under "architect" we need to add

	    "styles": [
              "./node_modules/bootstrap/dist/css/bootstrap.min.css",
              "./node_modules/ngx-bootstrap/datepicker/bs-datepicker.css",
              "./node_modules/font-awesome/css/font-awesome.min.css",
              "src/styles.scss"
            ],


In order to not include test files:
> ng g c nav-bar --skip-tests



Observables:

A sequence of items that arrives asynchronously over time.

Promises :

				 Succeed
				/
--------->	then	------->
				\
				 fail

Observables:

	    Cancel
	  /
--------->
	  \
	    fail/succeed ----> subscribe()  ----> map() ------> filter() ----> data




			GET api/products
Angular http client ------------------------> API
		    <------------------------
			http response: products[]
observables of products[]
	|
	|
map to a certain type of data
{product[], pageNumber, Count}
	|
	| subscribe
	|
shop component
	


HTTP, Observables, RxJS

1) HTTP Get request from ShopService
2) Receive the Observable and cast it into a Products array
3) Subscribe to observable from the component
4) Assign the products array to a local variable

RxJS:

1) Reactive extension of Javascript
2) Utility library to work with observables
3) Uses the pipe() method to chain RxJS operators together



Creating component withot generating a new folder:
> ng g c shop --skip-tests --flat 

Creating a service without generating a new folder:
> ng g s shop --skip-tests --flat


* -> 'asterik' means it will change something in the dom
e.g -> *ngFor


RsJS is used to manipulate Observables:

    return this.http.get<Pagination>(this.baseUrl+'products',{observe:'response',params})
      .pipe(
        map(resp=>{
          return resp.body
        })
      )


NOTE:
In tsconfig.json:
  "angularCompilerOptions": {
    "strictDomEventTypes":false, // add this line---------------------------------------
    "enableI18nLegacyMessageIdFormat": false
  }


ViewChild
DECORATOR
Property decorator that configures a view query. The change detector looks for the first element or 
the directive matching the selector in the view DOM. If the view DOM changes, and a new child matches the selector, 
the property is updated.



Implement lazy loading in Angular:
Set routes inside diff modules for module specific routes instead of loading them in the app.module.ts
If we specify all the routs in app module than all the other modules are loaded at the same time
 when app module is loaded

We will load the module specific routes when user wants that module specific route



Client - Error Handling:---------------------------------

To handle errors we receive from the API centrally and handled by http interceptors:

HttpInterceptor takes the type of error and redirects to a particular error route page


Client - Pazzazz:------------------------------------------

Improving UI of the application

NOTE:
npm ERR! ERESOLVE unable to resolve dependency tree -> this kind of err while installing npm packages

use 
> npm i xng-breadcrumb --legacy-peer-deps

USe this version:
npm i xng-breadcrumb@6.6.0 --legacy-peer-deps


Now breadcrumb is added as a global service and we can set its values by just adding its service as dependency injection


In order to use bootswatch in project:------

> npm i bootswatch

In the file angular.json we need to add "./node_modules/bootswatch/dist/united/bootstrap.min.css", inside "styles:[]" 
and restart the application


We can add a spinner utill all the things loads:----

> npm i ngx-spinner --legacy-peer-deps

Search ngx spinner and see how it is used



API - Basket:----------------------------------------------------------------

For basket we donto need to store data in DB
We will use Reddis for this which is an inmemory data store
is uses a key value pair ds

Redis:
1) In-memory data structure store
2) Supports strings, hashes, lists, sets, etc
3) key value store
4) Fast
5) Persists data by using snapshots every minute
6) Data can be given time to live
7) Great for caching data












































